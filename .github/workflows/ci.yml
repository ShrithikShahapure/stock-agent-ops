name: CI

on:
  pull_request:
    branches: [main]

permissions:
  id-token: write        # required for OIDC
  contents: read
  pull-requests: write
  security-events: write # required for SARIF upload (CodeQL / Trivy)

jobs:
  # ── Unit tests ───────────────────────────────────────────────────────────────
  test-go:
    name: Go Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run Go tests
        run: go test ./internal/...

  test-frontend:
    name: Frontend Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

  # ── Security scanning ──────────────────────────────────────────────────────
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # ── Trivy filesystem scan (IaC + deps + secrets) ───────────────────────
      - name: Trivy filesystem scan (SARIF)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: fs
          scan-ref: .
          format: sarif
          output: trivy-results.sarif
          severity: CRITICAL,HIGH

      - name: Upload Trivy SARIF to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-results.sarif
          category: trivy-fs

      - name: Trivy filesystem scan (table — fail on CRITICAL)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: fs
          scan-ref: .
          format: table
          severity: CRITICAL
          exit-code: '1'

      # ── gosec — Go static security analysis ────────────────────────────────
      - uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Run gosec
        uses: securego/gosec@master
        with:
          args: -fmt sarif -out gosec-results.sarif ./internal/...
        continue-on-error: true

      - name: Upload gosec SARIF
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: gosec-results.sarif
          category: gosec

      # ── Bandit — Python static security analysis ───────────────────────────
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install bandit
        run: pip install bandit[sarif]

      - name: Run bandit
        run: bandit -r src/ scripts/ -f sarif -o bandit-results.sarif --severity-level medium || true

      - name: Upload bandit SARIF
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: bandit-results.sarif
          category: bandit

      # ── npm audit — frontend dependency vulnerabilities ────────────────────
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - name: npm audit (high + critical)
        working-directory: frontend
        run: npm audit --audit-level=high || true

  # ── Terraform validate & plan ──────────────────────────────────────────────
  tf-validate:
    name: Terraform Validate & Plan
    runs-on: ubuntu-latest
    needs: [test-go, test-frontend]
    env:
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ci-role
          aws-region: us-east-1

      - name: Terraform Init
        run: terraform -chdir=terraform init

      - name: Terraform Format Check
        run: terraform -chdir=terraform fmt -check -recursive

      - name: Terraform Validate
        run: terraform -chdir=terraform validate

      - name: Terraform Plan
        id: plan
        continue-on-error: true
        run: terraform -chdir=terraform plan -no-color -input=false -detailed-exitcode

      - name: Post Terraform Plan to PR
        uses: trstringer/terraform-pr-commenter@v1
        if: always() && github.event_name == 'pull_request'
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          plan_output: ${{ steps.plan.outputs.stdout }}${{ steps.plan.outputs.stderr }}
          plan_exit_code: ${{ steps.plan.outputs.exitcode }}

      # ── Cost estimation (no external tools or API keys) ────────────────────
      # Parses the plan stdout already captured above, extracts resource types
      # and quantities, then prices them via the public AWS Pricing API
      # (no auth required). Writes /tmp/cost.json for the comment step.
      - name: Calculate cost estimate
        id: cost
        if: github.event_name == 'pull_request'
        env:
          PLAN_OUT: ${{ steps.plan.outputs.stdout }}
        run: |
          python3 - << 'PYEOF'
          import re, json, os, urllib.request, urllib.parse

          plan = os.environ["PLAN_OUT"]
          region = "us-east-1"

          # ── 1. Parse resources being created/updated from plan stdout ────────
          # Match lines like:  # module.eks.aws_eks_node_group.main will be created
          created = re.findall(
              r'#\s+([\w.]+)\s+will be (created|updated|replaced)',
              plan
          )
          resource_types = [addr.rsplit('.', 2)[-2] for addr, _ in created]

          def count(rtype):
              return resource_types.count(rtype)

          # ── 2. Extract configuration details from plan text ──────────────────
          # Instance type for node group
          instance_match = re.search(r'instance_types\s*=\s*\[\s*"([^"]+)"', plan)
          instance_type  = instance_match.group(1) if instance_match else "m5.xlarge"

          # Desired node count
          desired_match = re.search(r'desired_size\s*=\s*(\d+)', plan)
          node_count    = int(desired_match.group(1)) if desired_match else 2

          # EBS disk size per node (GB)
          disk_match = re.search(r'disk_size\s*=\s*(\d+)', plan)
          disk_gb    = int(disk_match.group(1)) if disk_match else 50

          # ── 3. Fetch live on-demand pricing from AWS Pricing API ─────────────
          def aws_price(service, filters):
              """Return USD/hr for the first matching product, or None."""
              base = "https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws"
              filters["location"]        = "US East (N. Virginia)"
              filters["termType"]        = "OnDemand"
              filters["pricePerUnit"]    = "USD"
              qs = urllib.parse.urlencode(
                  [("filters", f"[{json.dumps(filters)}]"),
                   ("max_results", 1),
                   ("format_version", "aws_v1")],
              )
              # Use the index endpoint that supports filter queries
              url = f"{base}/{service}/current/index.json"
              try:
                  with urllib.request.urlopen(url, timeout=10) as r:
                      data = json.load(r)
              except Exception:
                  return None
              for pid, p in data.get("products", {}).items():
                  attrs = p.get("attributes", {})
                  if all(attrs.get(k) == v for k, v in filters.items()
                         if k not in ("termType", "pricePerUnit", "location")):
                      terms = data.get("terms", {}).get("OnDemand", {}).get(pid, {})
                      for term in terms.values():
                          for dim in term.get("priceDimensions", {}).values():
                              try:
                                  return float(dim["pricePerUnit"]["USD"])
                              except (KeyError, ValueError):
                                  pass
              return None

          def ec2_price(itype):
              """Hourly on-demand price for a Linux EC2 instance in us-east-1."""
              url = (
                  "https://pricing.us-east-1.amazonaws.com/offers/v1.0/aws"
                  "/AmazonEC2/current/us-east-1/index.json"
              )
              try:
                  with urllib.request.urlopen(url, timeout=15) as r:
                      data = json.load(r)
              except Exception:
                  # fallback: well-known prices if the API is unreachable
                  fallback = {"m5.xlarge": 0.192, "m5.large": 0.096,
                              "t3.medium": 0.0416, "t3.large": 0.0832}
                  return fallback.get(itype, 0.192)
              for pid, p in data.get("products", {}).items():
                  a = p.get("attributes", {})
                  if (a.get("instanceType") == itype
                          and a.get("operatingSystem") == "Linux"
                          and a.get("tenancy") == "Shared"
                          and a.get("capacitystatus") == "Used"
                          and a.get("preInstalledSw") == "NA"):
                      terms = data["terms"]["OnDemand"].get(pid, {})
                      for term in terms.values():
                          for dim in term.get("priceDimensions", {}).values():
                              try:
                                  return float(dim["pricePerUnit"]["USD"])
                              except (KeyError, ValueError):
                                  pass
              return 0.192  # fallback

          # ── 4. Build line items ──────────────────────────────────────────────
          # Prices that are fixed / simple enough to hardcode
          FIXED = {
              # service                        $/hr
              "aws_eks_cluster":               0.10,
              "aws_nat_gateway":               0.045,
              "aws_eip":                       0.0,   # free when attached to NAT
              "aws_ecr_repository":            0.0,   # pay-per-GB storage, negligible
          }
          EBS_PER_GB_MONTH = 0.10   # gp2 in us-east-1

          items = []   # (label, qty, hourly_unit_cost)

          # EKS control plane
          n_eks = count("aws_eks_cluster")
          if n_eks:
              items.append(("EKS control plane", n_eks, 0.10))

          # EC2 worker nodes — fetch live price
          n_ng = count("aws_eks_node_group")
          if n_ng:
              unit_price = ec2_price(instance_type)
              items.append((f"EC2 {instance_type} × {node_count} nodes",
                             node_count, unit_price))
              ebs_hourly = (disk_gb * EBS_PER_GB_MONTH * node_count) / 730
              items.append((f"EBS gp2 {disk_gb} GB × {node_count} nodes",
                             1, ebs_hourly))

          # NAT Gateway
          n_nat = count("aws_nat_gateway")
          if n_nat:
              items.append(("NAT Gateway", n_nat, 0.045))

          # Everything else with a known fixed price
          for rtype, price in FIXED.items():
              if rtype in ("aws_eks_cluster", "aws_nat_gateway"):
                  continue   # already added
              n = count(rtype)
              if n and price > 0:
                  items.append((rtype.replace("aws_", ""), n, price))

          # ── 5. Compute totals ────────────────────────────────────────────────
          total_hourly = sum(qty * unit for _, qty, unit in items)
          total_daily   = total_hourly * 24
          total_monthly = total_hourly * 730

          result = {
              "total_daily":   round(total_daily,   2),
              "total_monthly": round(total_monthly, 2),
              "items": [
                  {
                      "label":   label,
                      "daily":   round(qty * unit * 24,  2),
                      "monthly": round(qty * unit * 730, 2),
                  }
                  for label, qty, unit in items
              ],
              "instance_type": instance_type,
              "node_count":    node_count,
              "region":        region,
          }

          with open("/tmp/cost.json", "w") as f:
              json.dump(result, f)

          print(f"Estimated cost — 1 day: ${total_daily:.2f}  |  1 month: ${total_monthly:.2f}")
          PYEOF

      - name: Post cost estimate to PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          script: |
            const fs   = require('fs');
            const data = JSON.parse(fs.readFileSync('/tmp/cost.json', 'utf8'));

            const rows = data.items
              .filter(i => i.monthly > 0)
              .sort((a, b) => b.monthly - a.monthly)
              .map(i => `| ${i.label} | $${i.daily.toFixed(2)} | $${i.monthly.toFixed(2)} |`)
              .join('\n');

            const body = [
              '## Infrastructure Cost Estimate',
              `> ${data.region} · ${data.node_count}x ${data.instance_type} nodes · on-demand pricing`,
              '',
              '| Period  | Estimated cost |',
              '|---------|---------------|',
              `| 1 day   | **$${data.total_daily.toFixed(2)}** |`,
              `| 1 month | **$${data.total_monthly.toFixed(2)}** |`,
              '',
              '<details>',
              '<summary>Per-resource breakdown</summary>',
              '',
              '| Resource | 1 day | 1 month |',
              '|----------|------:|--------:|',
              rows,
              `| **Total** | **$${data.total_daily.toFixed(2)}** | **$${data.total_monthly.toFixed(2)}** |`,
              '</details>',
              '',
              '_Prices sourced from the AWS Pricing API at run time. Excludes data transfer._',
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body.includes('Infrastructure Cost Estimate'));
            if (existing) {
              await github.rest.issues.updateComment({
                owner:      context.repo.owner,
                repo:       context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner:        context.repo.owner,
                repo:         context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }
