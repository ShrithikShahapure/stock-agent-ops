name: CD

on:
  push:
    branches: [main]

permissions:
  id-token: write
  contents: read
  security-events: write
  issues: write

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER: stock-agent-ops
  ECR_REPO_PREFIX: stock-agent-ops

jobs:
  # ── Quality gates (all three run in parallel) ────────────────────────────────
  security:
    uses: ShrithikShahapure/reuseable-actions/.github/workflows/security-scan.yml@main
    with:
      enable_trivy: true
      enable_gosec: true
      go_scan_path: './internal/...'
      enable_bandit: true
      python_scan_paths: 'src/ scripts/'
      enable_npm_audit: true
      node_working_directory: 'frontend'
      fail_on_critical: true
      post_pr_comment: false

  test-go:
    uses: ShrithikShahapure/reuseable-actions/.github/workflows/test-go.yml@main
    with:
      test_path: './internal/...'
      race: false
      coverage: false

  test-frontend:
    uses: ShrithikShahapure/reuseable-actions/.github/workflows/test-node.yml@main
    with:
      working_directory: 'frontend'
      test_command: 'npm test'

  # ── Build, push & scan images (matrix — API and frontend in parallel) ────────
  build-and-push:
    name: Build ${{ matrix.image }}
    runs-on: ubuntu-latest
    needs: [security, test-go, test-frontend]
    strategy:
      fail-fast: true
      matrix:
        include:
          - image: api
            dockerfile: backend/Dockerfile.go
            context: .
          - image: frontend
            dockerfile: frontend/Dockerfile
            context: frontend/
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ci-role
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: 'false'

      - name: Set image metadata
        id: meta
        run: |
          SHA="${GITHUB_SHA::8}"
          echo "sha=${SHA}" >> "$GITHUB_OUTPUT"
          echo "ecr=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_PREFIX }}/${{ matrix.image }}" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
            | docker login --username AWS \
                           --password-stdin \
                           ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Build & push
        run: |
          IMAGE="${{ steps.meta.outputs.ecr }}"
          SHA="${{ steps.meta.outputs.sha }}"
          docker build -f ${{ matrix.dockerfile }} \
            -t "${IMAGE}:${SHA}" -t "${IMAGE}:latest" \
            ${{ matrix.context }}
          docker push "${IMAGE}:${SHA}"
          docker push "${IMAGE}:latest"

      - name: Trivy scan (SARIF)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.meta.outputs.ecr }}:${{ steps.meta.outputs.sha }}
          format: sarif
          output: trivy-${{ matrix.image }}.sarif
          severity: CRITICAL,HIGH
          ignore-unfixed: true

      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v4
        if: success() || failure()
        with:
          sarif_file: trivy-${{ matrix.image }}.sarif
          category: trivy-${{ matrix.image }}-image
        continue-on-error: true

      - name: Fail on CRITICAL vulnerabilities
        run: |
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
          trivy image --severity CRITICAL --exit-code 1 --no-progress --ignorefile .trivyignore \
            "${{ steps.meta.outputs.ecr }}:${{ steps.meta.outputs.sha }}"

  # ── Gate: all matrix builds must pass before downstream jobs ─────────────────
  images-ready:
    name: Images Ready
    runs-on: ubuntu-latest
    needs: build-and-push
    outputs:
      image_tag: ${{ steps.tag.outputs.sha }}
    steps:
      - name: Set image tag
        id: tag
        run: echo "sha=${GITHUB_SHA::8}" >> "$GITHUB_OUTPUT"

  # ── Terraform plan + cost estimate (parallel with build) ─────────────────────
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [security, test-go, test-frontend]
    outputs:
      plan_summary: ${{ steps.plan-summary.outputs.summary }}
      cost_table: ${{ steps.cost-format.outputs.table }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ci-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: terraform -chdir=terraform init

      - name: Verify S3 backend
        run: |
          echo "Checking Terraform backend configuration..."
          BACKEND=$(terraform -chdir=terraform show -json 2>/dev/null | python3 -c "
          import sys, json
          try:
              data = json.load(sys.stdin)
              print('s3' if data else 'unknown')
          except:
              print('configured')
          " 2>/dev/null || echo "configured")
          echo "Backend: S3 (stock-agent-ops-tfstate)"
          echo "Lock table: stock-agent-ops-tflock"
          grep -A5 'backend "s3"' terraform/main.tf

      - name: Terraform Plan
        id: plan
        run: |
          terraform -chdir=terraform plan -no-color -input=false -out=tfplan 2>&1 | tee /tmp/plan.txt

      - name: Extract plan summary
        id: plan-summary
        if: always()
        run: |
          SUMMARY=$(tail -40 /tmp/plan.txt | head -35)
          {
            echo "summary<<EOFPLAN"
            echo "$SUMMARY"
            echo "EOFPLAN"
          } >> "$GITHUB_OUTPUT"

      - name: Write Terraform Plan to job summary
        if: always()
        run: |
          echo "## Terraform Plan" >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"
          cat /tmp/plan.txt >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Calculate cost estimate
        id: cost
        run: |
          python3 - << 'PYEOF'
          import re, json, os

          with open("/tmp/plan.txt") as f:
              plan = f.read()
          region = "us-east-1"

          created = re.findall(
              r'#\s+([\w.]+)\s+will be (created|updated|replaced)', plan
          )
          resource_types = [addr.rsplit('.', 2)[-2] for addr, _ in created]

          def count(rtype):
              return resource_types.count(rtype)

          instance_match = re.search(r'instance_types\s*=\s*\[\s*"([^"]+)"', plan)
          instance_type  = instance_match.group(1) if instance_match else "m5.xlarge"

          desired_match = re.search(r'desired_size\s*=\s*(\d+)', plan)
          node_count    = int(desired_match.group(1)) if desired_match else 2

          disk_match = re.search(r'disk_size\s*=\s*(\d+)', plan)
          disk_gb    = int(disk_match.group(1)) if disk_match else 50

          EC2_PRICES = {"m5.xlarge": 0.192, "m5.large": 0.096,
                        "t3.medium": 0.0416, "t3.large": 0.0832}
          EBS_PER_GB_MONTH = 0.10

          items = []
          n_eks = count("aws_eks_cluster")
          if n_eks:
              items.append(("EKS control plane", n_eks, 0.10))

          n_ng = count("aws_eks_node_group")
          if n_ng:
              price = EC2_PRICES.get(instance_type, 0.192)
              items.append((f"EC2 {instance_type} x {node_count} nodes",
                             node_count, price))
              ebs_hourly = (disk_gb * EBS_PER_GB_MONTH * node_count) / 730
              items.append((f"EBS gp2 {disk_gb} GB x {node_count} nodes",
                             1, ebs_hourly))

          n_nat = count("aws_nat_gateway")
          if n_nat:
              items.append(("NAT Gateway", n_nat, 0.045))

          total_hourly  = sum(qty * unit for _, qty, unit in items)
          total_daily   = total_hourly * 24
          total_monthly = total_hourly * 730

          result = {
              "total_daily":   round(total_daily, 2),
              "total_monthly": round(total_monthly, 2),
              "items": [
                  {"label": label, "daily": round(qty * unit * 24, 2),
                   "monthly": round(qty * unit * 730, 2)}
                  for label, qty, unit in items
              ],
              "instance_type": instance_type,
              "node_count": node_count,
              "region": region,
          }
          with open("/tmp/cost.json", "w") as f:
              json.dump(result, f)
          PYEOF

      - name: Format cost for approval issue
        id: cost-format
        run: |
          python3 - << 'PYEOF'
          import json, os

          data = json.load(open("/tmp/cost.json"))
          lines = []
          lines.append(f"> {data['region']} · {data['node_count']}x {data['instance_type']} nodes · on-demand pricing")
          lines.append("")
          lines.append("| Period | Estimated Cost |")
          lines.append("|--------|---------------|")
          lines.append(f"| Daily | **${data['total_daily']:.2f}** |")
          lines.append(f"| Monthly | **${data['total_monthly']:.2f}** |")
          lines.append("")
          lines.append("| Resource | Daily | Monthly |")
          lines.append("|----------|------:|--------:|")
          for i in data["items"]:
              if i["monthly"] > 0:
                  lines.append(f"| {i['label']} | ${i['daily']:.2f} | ${i['monthly']:.2f} |")
          lines.append(f"| **Total** | **${data['total_daily']:.2f}** | **${data['total_monthly']:.2f}** |")
          table = "\n".join(lines)

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write("table<<EOFCOST\n")
              f.write(table + "\n")
              f.write("EOFCOST\n")
          PYEOF

      - name: Write cost estimate to job summary
        if: always()
        run: |
          python3 - << 'PYEOF'
          import json
          data = json.load(open("/tmp/cost.json"))
          lines = []
          lines.append("## Infrastructure Cost Estimate")
          lines.append(f"> {data['region']} · {data['node_count']}x {data['instance_type']} nodes · on-demand pricing")
          lines.append("")
          lines.append("| Period  | Estimated cost |")
          lines.append("|---------|---------------|")
          lines.append(f"| 1 day   | **${data['total_daily']:.2f}** |")
          lines.append(f"| 1 month | **${data['total_monthly']:.2f}** |")
          lines.append("")
          lines.append("| Resource | 1 day | 1 month |")
          lines.append("|----------|------:|--------:|")
          for i in data["items"]:
              if i["monthly"] > 0:
                  lines.append(f"| {i['label']} | ${i['daily']:.2f} | ${i['monthly']:.2f} |")
          lines.append(f"| **Total** | **${data['total_daily']:.2f}** | **${data['total_monthly']:.2f}** |")
          lines.append("")
          lines.append("_Prices are hardcoded estimates. Excludes data transfer._")
          with open("/tmp/cost_summary.md", "w") as f:
              f.write("\n".join(lines))
          PYEOF
          cat /tmp/cost_summary.md >> "$GITHUB_STEP_SUMMARY"

  # ── Single approval gate with plan + cost in the issue ───────────────────────
  approve-terraform:
    name: Approve Terraform & Deploy
    runs-on: ubuntu-latest
    needs: [terraform-plan, images-ready]
    steps:
      - uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: ShrithikShahapure
          minimum-approvals: 1
          issue-title: "Approve Terraform Apply & Deploy — ${{ github.sha }}"
          issue-body: |
            ## Terraform Plan

            ```
            ${{ needs.terraform-plan.outputs.plan_summary }}
            ```

            ## Cost Estimate

            ${{ needs.terraform-plan.outputs.cost_table }}

            ---

            **Commit:** `${{ github.sha }}`
            **Image tag:** `${{ needs.images-ready.outputs.image_tag }}`

            Full plan details: [workflow run summary](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            **Approve** this issue to run `terraform apply` and deploy to EKS, or **close** to cancel.
          exclude-workflow-initiator-as-approver: false

  # ── Terraform apply (only after approval) ────────────────────────────────────
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [approve-terraform, images-ready]
    outputs:
      cluster_name: ${{ steps.tf-outputs.outputs.cluster_name }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ci-role
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 7200

      - name: Terraform Init
        run: terraform -chdir=terraform init

      - name: Terraform Apply
        run: terraform -chdir=terraform apply -auto-approve -input=false

      - name: Capture Terraform outputs
        id: tf-outputs
        run: |
          CLUSTER=$(terraform -chdir=terraform output -raw cluster_name)
          echo "cluster_name=${CLUSTER}" >> "$GITHUB_OUTPUT"

  # ── Deploy to EKS (two-pass: API first, then frontend with real URL) ─────────
  deploy-to-eks:
    name: Deploy to EKS
    runs-on: ubuntu-latest
    needs: [images-ready, terraform-apply]
    env:
      SHA: ${{ needs.images-ready.outputs.image_tag }}
      CLUSTER_NAME: ${{ needs.terraform-apply.outputs.cluster_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-ci-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Set ECR URLs
        id: ecr
        run: |
          ECR_API="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_PREFIX }}/api"
          ECR_FRONTEND="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_PREFIX }}/frontend"
          echo "api=${ECR_API}" >> "$GITHUB_OUTPUT"
          echo "frontend=${ECR_FRONTEND}" >> "$GITHUB_OUTPUT"

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name "${{ env.CLUSTER_NAME }}" \
            --region ${{ env.AWS_REGION }}

      # Pass 1: deploy everything except the frontend
      - name: Apply non-frontend resources
        run: |
          ECR_API="${{ steps.ecr.outputs.api }}"

          # Apply supporting services
          kubectl apply -f k8s/redis.yaml
          kubectl apply -f k8s/qdrant.yaml
          kubectl apply -f k8s/volumes.yaml
          kubectl apply -f k8s/prometheus.yaml
          kubectl apply -f k8s/grafana.yaml
          kubectl apply -f k8s/llama.yaml

          # Apply API deployment + services from base manifest
          kubectl apply -f k8s/api.yaml

          # Patch: set ECR image (replaces imagePullPolicy: Never's local image)
          kubectl set image deployment/api \
            api="${ECR_API}:${{ env.SHA }}"

          # Patch: override imagePullPolicy from Never to IfNotPresent for ECR
          kubectl patch deployment/api --type=json \
            -p='[{"op":"replace","path":"/spec/template/spec/containers/0/imagePullPolicy","value":"IfNotPresent"}]'

          # Patch: inject FMI_API_KEY from k8s secret (if secret exists)
          kubectl set env deployment/api --from=secret/app-secrets --prefix="" 2>/dev/null \
            || echo "Note: app-secrets secret not found, skipping FMI_API_KEY injection"

      - name: Wait for API LoadBalancer hostname
        id: api-lb
        run: |
          echo "Waiting for API LoadBalancer to be assigned a hostname..."
          for i in $(seq 1 30); do
            HOSTNAME=$(kubectl get svc api \
              -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$HOSTNAME" ]; then
              echo "hostname=${HOSTNAME}" >> "$GITHUB_OUTPUT"
              echo "API LB: ${HOSTNAME}"
              break
            fi
            echo "Attempt ${i}/30 — waiting 10s..."
            sleep 10
          done
          if [ -z "$HOSTNAME" ]; then
            echo "ERROR: LoadBalancer hostname not assigned after 5 minutes"
            exit 1
          fi

      # Pass 2: deploy frontend with the real public API URL
      - name: Patch & apply frontend
        env:
          API_HOSTNAME: ${{ steps.api-lb.outputs.hostname }}
        run: |
          ECR_FRONTEND="${{ steps.ecr.outputs.frontend }}"

          # Apply frontend deployment + service from base manifest
          kubectl apply -f k8s/frontend.yaml

          # Patch: set ECR image
          kubectl set image deployment/frontend \
            frontend="${ECR_FRONTEND}:${{ env.SHA }}"

          # Patch: override imagePullPolicy from Never to IfNotPresent for ECR
          kubectl patch deployment/frontend --type=json \
            -p='[{"op":"replace","path":"/spec/template/spec/containers/0/imagePullPolicy","value":"IfNotPresent"}]'

          # Patch: set the real API_URL (browser-accessible LB hostname)
          kubectl set env deployment/frontend \
            API_URL="http://${API_HOSTNAME}:8000"

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/api --timeout=300s
          kubectl rollout status deployment/frontend --timeout=300s

      - name: Smoke test
        env:
          API_HOSTNAME: ${{ steps.api-lb.outputs.hostname }}
        run: |
          sleep 15
          STATUS=$(curl -sf "http://${API_HOSTNAME}:8000/health" | python3 -c \
            "import sys,json; d=json.load(sys.stdin); print(d.get('status',''))")
          if [ "$STATUS" != "healthy" ]; then
            echo "Health check failed: got '${STATUS}'"
            exit 1
          fi
          echo "Health check passed."
